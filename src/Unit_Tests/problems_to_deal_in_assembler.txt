
ğŸ” Î¤Î± ÎšÏÏÎ¹Î± Î ÏÎ¿Î²Î»Î®Î¼Î±Ï„Î± & Î›ÏÏƒÎµÎ¹Ï‚:
Î ÏÏŒÎ²Î»Î·Î¼Î± 1: "Î ÏÏ‚ ÏƒÏ€Î¬Ï‰ Ï„Î· Î³ÏÎ±Î¼Î¼Î®;"
assembly"  add   x1  ,   x2 ,  x3  # comment"
Î£ÎºÎ­ÏˆÎ·:

Î‘Ï†Î±Î¯ÏÎµÏƒÎ· noise (comments, spaces)
ÎŸÎ¼Î¿Î¹ÏŒÎ¼Î¿ÏÏ†Î¿ format (ÎºÏŒÎ¼Î¼Î±Ï„Î± â†’ spaces)
Split ÏƒÎµ tokens

Î›ÏÏƒÎ·:
pythonline.split('#')[0]          # Remove comments
line.replace(',', ' ')      # Uniform separators
line.split()               # Smart whitespace handling
Î ÏÏŒÎ²Î»Î·Î¼Î± 2: "Î¤Î¹ ÎºÎ¬Î½Ï‰ Î¼Îµ Ï„Î± labels;"
assemblymain: add x1, x2, x3
beq x1, x2, main
Î£ÎºÎ­ÏˆÎ·:

Labels ÎµÎ¯Î½Î±Î¹ addresses
Î§ÏÎµÎ¹Î¬Î¶Î¿Î¼Î±Î¹ two passes:

Pass 1: ÎœÎ¬Î¶ÎµÏˆÎµ Ï„Î± labels
Pass 2: Î‘Î½Ï„Î¹ÎºÎ±Ï„Î¬ÏƒÏ„Î·ÏƒÎ­ Ï„Î±



Î›ÏÏƒÎ·:
python# Pass 1: Store labels
labels["main"] = 0

# Pass 2: Resolve references  
offset = labels["main"] - current_address - 1
Î ÏÏŒÎ²Î»Î·Î¼Î± 3: "Î ÏÏ‚ ÎºÏ‰Î´Î¹ÎºÎ¿Ï€Î¿Î¹Ï Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¿ÏÏ‚ Ï„ÏÏ€Î¿Ï…Ï‚ ÎµÎ½Ï„Î¿Î»ÏÎ½;"
Î£ÎºÎ­ÏˆÎ·:

ÎšÎ¬Î¸Îµ Ï„ÏÏ€Î¿Ï‚ Î­Ï‡ÎµÎ¹ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÏŒ format
Î§ÏÎµÎ¹Î¬Î¶Î¿Î¼Î±Î¹ classification system
Î§Ï‰ÏÎ¹ÏƒÏ„Î® encoding logic Î³Î¹Î± ÎºÎ±Î¸Î­Î½Î±

Î›ÏÏƒÎ·:
python# Step 1: Classify
inst_type = get_instruction_type("ADD")  # â†’ "R"

# Step 2: Route to appropriate encoder
if inst_type == 'R':
    return _encode_r_type(opcode, operands)
elif inst_type == 'I':
    return _encode_i_type(opcode, operands)

ğŸ§  Î— Î£ÎºÎµÏ€Ï„Î¹ÎºÎ® Î”Î¹Î±Î´Î¹ÎºÎ±ÏƒÎ¯Î±:
1. Top-Down Design:
assemble_file()
    â†“
_first_pass() + _second_pass()
    â†“
parse_instruction_line() + encode_instruction()
    â†“
_encode_r_type(), _encode_i_type(), etc.
2. Separation of Concerns:

Parsing â‰  Encoding
Label handling â‰  Instruction processing
Error handling ÏƒÎµ ÎºÎ¬Î¸Îµ ÎµÏ€Î¯Ï€ÎµÎ´Î¿

3. Data-Driven Design:
python# Î‘Î½Ï„Î¯ Î³Î¹Î± giant if-else:
opcodes = {'ADD': 0x0, 'SUB': 0x1, ...}
register_map = {'x0': 0, 'ra': 1, ...}

ğŸ¯ ÎšÏÎ¯ÏƒÎ¹Î¼ÎµÏ‚ Î‘Ï€Î¿Ï†Î¬ÏƒÎµÎ¹Ï‚ Ï€Î¿Ï… Ï€Î®ÏÎ±Î¼Îµ:
Î‘. Two-Pass Architecture
Î“Î¹Î±Ï„Î¯; Labels Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¿ÏÎ½ forward references:
assemblybeq x1, x2, end    # Î”ÎµÎ½ Î¾Î­ÏÏ‰ Ï€Î¿Ï… ÎµÎ¯Î½Î±Î¹ Ï„Î¿ "end" Î±ÎºÏŒÎ¼Î±!
add x1, x1, 1
end: halt          # Î¤ÏÏÎ± Ï„Î¿ Î²ÏÎ®ÎºÎ±!
Î’. Flexible Register Naming
pythonregister_map = {'x1': 1, 'ra': 1}  # Both map to register 1
Î“Î¹Î±Ï„Î¯; Î”Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¿Î¯ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î­Ï‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¬ conventions.
Î“. Robust Error Handling
pythontry:
    rd = self.parse_register(operands[0])
except ValueError as e:
    print(f"Error on line {line_num}: {e}")
Î“Î¹Î±Ï„Î¯; Assembly debugging ÎµÎ¯Î½Î±Î¹ Î´ÏÏƒÎºÎ¿Î»Î¿ - Ï‡ÏÎµÎ¹Î±Î¶ÏŒÎ¼Î±ÏƒÏ„Îµ ÎºÎ±Î»Î¬ error messages.

ğŸš€ Î¤Î¿ Pattern Ï€Î¿Ï… Î±ÎºÎ¿Î»Î¿Ï…Î¸Î®ÏƒÎ±Î¼Îµ:
1. Clean Input:
python"  ADD  x1, x2,x3 # comment" â†’ "ADD x1 x2 x3"
2. Parse Structure:
python"ADD x1 x2 x3" â†’ {'instruction': 'ADD', 'operands': ['x1', 'x2', 'x3']}
3. Classify & Validate:
python'ADD' â†’ 'R-type' â†’ validate_3_operands() â†’ parse_registers()
4. Encode:
pythonopcode=0x0, rd=1, rs1=2, rs2=3 â†’ (0x0<<12)|(1<<8)|(2<<4)|3 â†’ 0x0123

ğŸ’¡ Î¤Î¹ Î¼Î¬Î¸Î±Î¼Îµ;

Divide & Conquer - ÎœÎµÎ³Î¬Î»Î± Ï€ÏÎ¿Î²Î»Î®Î¼Î±Ï„Î± â†’ Î¼Î¹ÎºÏÎ¬ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹Î±
Data Structures Matter - Î£Ï‰ÏƒÏ„Î¬ dictionaries Î±Ï€Î»Î¿Ï€Î¿Î¹Î¿ÏÎ½ Ï„Î± Ï€Î¬Î½Ï„Î±
Error Handling is Critical - Debugging assembly Ï‡Ï‰ÏÎ¯Ï‚ ÎºÎ±Î»Î¬ errors = nightmare
Test Early & Often - ÎšÎ¬Î¸Îµ function Î¾ÎµÏ‡Ï‰ÏÎ¹ÏƒÏ„Î¬ Ï€ÏÏÏ„Î±
Think in Layers - Parsing layer, Logic layer, Encoding layer